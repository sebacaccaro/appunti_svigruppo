\documentclass[a4paper,12pt]{article}

% Se vuoi che il pdf sia in formato mobile, decommenta la linea qui sotto e commenta la prima linea del codice
%\input{../../.Latex_stuff/mobile.tex}

\input{../../.Latex_stuff/commands.tex}



\sloppy
\begin{document}

\begin{titlepage}
\begin{center}
	\Large{\textbf{Appunti di Sviluppo Software in Gruppi di Lavoro Complessi}}
\vfill
\normalsize{Caccaro Sebastiano}\\
\normalsize{A.A.2019/2020}
\end{center}
\end{titlepage}

\tableofcontents

\clearpage


%Lezione di Giovedi 4 Ottobre 2019
\lessonDate{4 Ottobre 2019}
\section{Modelli Organizzativi}
Lo sviluppo software presenta dei problemi intrinseci:
\begin{itemize}
\item \textbf{Non linearità del software}: Un errore molto piccolo può avere conseguenze catastrofiche
\item Obiettivi poco chiari e mutabili
\end{itemize}
Questi problemi esistono tutt'oggi e sono difficilmente mitigabili. Esistono invece delle criticità che possono essere risolte.

\definition{Legge di Brooks}{Aggiungere personale ad un progetto in ritardo lo farà solo ritardare.}

Nello sviluppo software, non tutto è facilmente parallelizzabile. Non posso far nascere un bambino da 9 donne in un mese. Va da se che l'\textbf{effort} non corrisponde al \textbf{progress}. \`E molto facile stimare quanto si è lavorato, è meno facile misurare di quanto si è progredito, e questo può causare ulteriori ritardi. La soluzione non è aggiungere personale.

Un progetto deve mantenere sempre la sua \textbf{integrità concettuale}.\\
Per far ciò Brooks propone vari modelli.

\subsection{Modelli a Cattedrale e sala Operatoria}
\begin{itemize}
\item \textbf{Cattedrale}: Tenere rigorosamente separata progettazione e implementazione. L'implementatore deve quindi curarsi solamente di seguire quanto progettato. Si mantiene così la visione originale del progetto. Questo modello ha però il difetto di essere molto poco flessibile, e difetti nel progetto comportano problematiche enormi.
\item \textbf{Sala operatoria:} Solamente il chirurgo (superbravo) si occupa di fare le cose importanti, gli altri nella sala fanno praticamente solo da assistente. Il vero lavoro viene svolto solamente dal chirurgo (una sola persona).
\end{itemize}
Questi modelli fanno però due grosse supposizioni:
\begin{itemize}
\item Che sia possibile accentare lo sforzo creativo in un'unica persona.
\item Che sia possibile separare completamente progettazione e implementazione.
\end{itemize}
La maggior parte delle volte, tuttavia, queste supposizioni non si rivelano corrette.

\subsubsection{Critiche}
Eric Raymond contrappone il modello a \textbf{bazaar} (usato per lo sviluppo di Linux) contro la cattedrale di Brooks, osservando che il modello open source di Linux produca software di qualità, pur non usando i modelli proposti da brooks.
\lessonDate{8 Ottobre 2019}

\subsection{Modello a Bazaar}
Usato in Linux, si identifica esplicitamente come l'antitesi del modello a cattedrale. Raymond condivide l'analisi di Brooks, ma arriva alla conclusione che ci possano essere altri modelli in certe situazioni.
\definition{Baazar}{Mercato autogestito, dove chiunque può mettere una bancarella dove vuole, quando vuole}

\begin{figure}[H]
	\centering
	 \includegraphics[width=0.6\linewidth]{Immagini/bazaar.jpg}
	 \caption{Un bazaar}
\end{figure}

Nel modello a Baazar, ognuno fa i propri interessi e sviluppa ciò che gli interessa sviluppare. Non c'è quindi un obiettivo comune, ma nel perseguire i propri interessi chi sviluppa nel modello a Baazar contribuisce a tenere viva la codebase. Questo processo non segue un modello prefissato, e quindi produce una sorta di organismo in continua evoluzione, il quale scopo quindi non diventa obsoleto.
Ma cosa permette a progetti come questi, che non adottano i modelli di Brooks, di non fallire?
\begin{itemize}
 \item Le persone non lavorano perchè costrette a farlo per un'azienda. Chi contribuisce lo fa per interessi personali, ed è quindi interessato e motivato ("personal itch")
 \item Gli utenti sono considerati co-sviluppatori, ciò aiuta a individuare e risolvere bug più velocemente
 \item Rilasciare presto e frequentemente, in modo tale da avere sempre feedback
\end{itemize}

\definition{Legge di Linux}{Data una base di beta-tester e co-sviluppatori abbastanza amplia, quasi ogni problema può essere scoperto e risolto velocemente da qualcuno.}

Per Brooks un numero elevato di utenti porta inevitabilmente ad avere più bug, in quanto ogni utente può vedere problemi diversi. Raymond invece considera gli utenti come collaboratori, che possono aiutare lo sviluppatore.\\
Anche questo modello, in teoria fantastico, in pratica è abbastanza idealistico.

\subsection{Modello a Kibbutz}
Per poter supportare delle applicazioni, un sistema deve fornire dei servizi adeguati, come kernel, driver, librerie di sistema ecc.\\
Linux è solamente un kernel, non ci si possono far girare applicazioni. Nasce quindi li concetto di \textbf{distribuzione}, ovvero un sistema completo immediatamente utilizzabile. Un programma viene quindi distribuito sotto forma di pacchetto, che è progettato per lavorare con una distribuzione (esempio pacchetto .deb).

\definition{Kibbutz}{Fattoria, villaggio, impresa collettiva nata in Israele, con scopo di popolare il nuovo stato}

\begin{figure}[H]
	\centering
	 \includegraphics[width=0.6\linewidth]{Immagini/kibbutz.jpg}
	 \caption{Un kibbutz}
\end{figure}

Non parliamo quindi più di un bazaar, dove ognuno fa quello che vuole. Ma di un'organizzazione strutturata e organizzata, con uno scopo comune. Sono presenti delle \textbf{policy} prestabilite, che hanno dei corrispettivi tool che assicurano il rispetto di tali policy. Queste policy hanno l'effetto di abbassare drasticamente l'effort comunicativo fra i vari contributori al progetto. Praticamente molti progetti open-source sono organizzati a kibbutz, perchè il modello a Baazar non è una strada viabile. 
\\Questa è la filosofia adottata da Debian.

\subsubsection{Esempio di Debian}
Fin dall'inizio, Debian è openSource (ad oggi circa 1900 sviluppatori, che devono superare degli esami). Supporta più di 10 architetture e tre kernel diversi (una distribuzione non è per forza linux).\\
In Debian, ogni pacchetto contiene alcune informazioni come:
\begin{itemize}
 \item Nome
 \item Architetture supportate
 \item \textbf{Dipedenze}: tutti i pacchetti che servono al corretto funzionamento del mio pacchetto. Il solo codice sorgente del mio pacchetto è inutile senza queste informazioni
\end{itemize}

Nel pacchetto sono contenuti anche i propri file di configurazione. Questi file sono specificati nei pacchetti, quindi un upgrade non va a intaccare la configurazione. In caso ci siano problemi, chiedo all'utente di fare il merge.

\lessonDate{10 Ottobre}
\section{Metodologie Agili}
Negli anni 90 si pensa che il modo per aumentare la qualità di processi debba dipendere da una gran enfasi sulla produzione di documentazione, UML ecc. Secondo gli agilisti, tutto il focus che viene posto sui processi non risulta effettivamente in software di qualità.\\ Nascono quindi dei nuovi modelli organizzativi che reagiscono a queste cose pallose, come:
\begin{itemize}
\item eXtreme Programming
\item Scrum
\end{itemize}
Il manifesto della \textbf{Programmazione Agile} viene pubblicato nel 2001, ed esprime i seguenti concetti:
\begin{enumerate}
\item Individui e interazioni \textgreater\space Processi e strumenti
\item Software funzionante \textgreater\space Documentazione esaustiva
\item Collaborazione cliente \textgreater\space Negoziazione contratti
\item Rispondere al cambiamento \textgreater\space Seguire un piano
\end{enumerate}
Tutti questi punti sono un però \textbf{molto generici e idealistici}, e sono sì belli, ma poco applicabili. Il più concreto di questi è forse il punto 4, perchè riconosce il fatto che è molto facile sbagliare la pianificazione. \E meglio quindi salvare risorse per potersi adattare a nuove situazioni.
\lessonDate{15 Ottobre 2019}
\vspace{0.5cm}
\noindent Al contrario di quanto si è portati a pensare, agile non significa il rifiuto dei processi, ma piuttosto il rifiuto di continue verifiche e benchmark come misura della qualità di quanto prodotto. Quello che fanno gli agilisti è sostituire al canone fatto di processi e misurazioni un canone con dei principi astratti più o meno condivisibili.

\subsection{Principi agile}
Il manifesto agile espone 12 principi. Quelli più generali sono:
\begin{itemize}
\item Rilasciare software di valore, fin da subito e in maniera continua: la prima parte è un po' ovvia, La parte interessante è \textbf{fin da subito} e \textbf{in maniera continua}
\item Consegnare \textbf{frequentemente} software funzionante
\item Il \textbf{software funzionante} è la principale misura di progresso: attenzione che funzionante non vuol dire che soddisfa per forza le esigenze dell'utente
\item \textbf{Cambiamenti nei requisiti} anche a stadi avanzati
\item Committenti e sviluppatori devono lavorare insieme \textbf{quotidianamente}: è un po' più uno \textbf{scazzo} per il committente, e attribuisce meno responsabilità allo sviluppatore, evitando conflitti
\item Conversazione faccia a faccia: ci si capisce meglio parlandosi e vedendosi
\end{itemize}

Sono presenti inoltre dei principi riguardanti il gruppo di lavoro:
\begin{itemize}
\item Individui motivati e ben supportati (abbastanza ovvio)
\item Sviluppo sostenibile, ovvero essere grado di \textbf{mantenere indefinitamente un ritmo costante}: non faccio la tirata dell'ultimo secondo, perchè poi avrò delle ripercussioni
\item Eccellenza tecnica: contrapposta alla qualità astratta nei modelli di Brooks
\item Team che si auto-organizzano: sia per mantenere la motivazione, sia per riuscire a seguire dei ritmi sostenibili per il team
\item A intervalli regolari il team riflette su come diventare più efficacie: è la stessa cosa di un controllo sui processi, ma implementato in modo più libero
\end{itemize}
L'ultimo principio invece è abbastanza poetico:
\begin{itemize}
\item La semplicità - l'arte di massimizzare la quantità di lavoro non svolto - è essenziale
\end{itemize}

\subsection{Principi agile nella pratica}
Questi principi nell'implementazione in canoni agile si traducono nelle seguenti prescrizioni:
\begin{itemize}
\item Team \textbf{piccoli} e \textbf{auto-organizzati}, senza manager tradizionali, ma facilitatori.
\item Rifiuto di azioni e decisioni \textbf{big upfront}, sviluppo interattivo aperto alla variazioni in corso d'opera: cerco di non prendere decisioni troppo importati a meno che non posso fare altrimenti. Mi preoccupo di possibili cambiamenti solo quando il problema si pone effettivamente. Spesso no big upfront è noto con YAGNI (you aren't gonna need it), quindi non sviluppo una cosa finchè non è completamente chiaro che ne ho bisogno. Cerco quindi di evitare l'\textbf{over engeneering}
\item Misura e controllo del processo di sviluppo, con pianificazioni con orizzonti temporali e funzionali ridotti: ovvero mi concentro molto su quello che farò oggi, non mi preoccupo di quello che farò fra 2 settimane
\item Enfasi su testing, intesa come tecnica di sviluppo.
\end{itemize}

\subsubsection{Enfasi sul testing}
I requisiti sono sostituiti dalle \textbf{User Stories}, ovvero dei template di frasi che il committente compila.
\begin{center}
\textit{As a} \texttt{USER TYPE} \textit{I want} \texttt{FUNCTIONALITY} \textit{so that} \texttt{MOTIVATION}
\end{center}
Queste frasi vengono usate per capire cosa bisogna fare, e per valutare se vale davvero la pena farlo.\\
La specifica che l'ingegneria classica produce è invece sostituita da \textbf{casi di test}, che vengono associati alle user stories. Il mio scopo è quindi quello di far passare i test, ovvero sto facendo \textbf{Test Driven Development (TDD)}.\\
Deve quindi essere chiaro che il \textbf{test non è un elemento di verifica}.





\end{document}
