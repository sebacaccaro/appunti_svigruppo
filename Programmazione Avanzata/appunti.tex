\documentclass[a4paper,12pt]{article}

% Se vuoi che il pdf sia in formato mobile, decommenta la linea qui sotto e commenta la prima linea del codice
%\input{../.Latex_stuff/mobile.tex}

\input{../.Latex_stuff/commands.tex}
\newcommand{\pyRef}[1]{{\color{blue}{DIP pg#1}}}

\begin{document}

\begin{titlepage}
\begin{center}
	\Large{\textbf{Appunti di Programmazione Avanzata}}
\vfill
\normalsize{Caccaro Sebastiano}\\
\normalsize{A.A.2019/2020}
\end{center}
\end{titlepage}

\tableofcontents


\clearpage


%Lunedi 7 ottobre
\lessonDate{7 Ottobre 2019}
\section{Informazioni sul corso}
\begin{itemize}
	\item\textbf{Login:}pa\\
	\item\textbf{Password:}PA+\#2009\#\\
	\item\textbf{Sito del corso:} \url{cazzola.di.unimi.it/pa.html}\\
\end{itemize}
Libri e cose del genere sono presenti nelle slide. L'esame è scritto e si svolge al computer.

\section{Python in breve}
\E un linguaggio di scripting multi-paradigma, quindi imperativo, object-oriented, e funzionale. \E interpretato, \textbf{object-based} (=ogni cosa è un oggetto) e tipizzato dinamicamente.\\
Nel corso si userà \textbf{Python 3}.

\subsection{Osservazioni su humanize.py}
\begin{itemize}
	\item Le variabili non hanno un tipo statico. Il tipo dinamico è attaccato all'oggetto che contiene la variabile.
	\item Supporta alcune strutture dati base di default. Ad esempio i dizionari (HashMap), liste ecc.
	\item Si può indentare con i tab o con gli spazi, molto meglio con gli spazi.
	\item Dopo la prima linea della funzione se commento con \texttt{``` commento ```}, posso fare un commento tipo javadoc.
	\item Come in javascript, tutto è un oggetto, anche le funzioni. Anche i primitivi sono degli oggetti. Come in JS, posso passare le funzioni come parametri.
	\item \texttt{\_\_name\_\_} assume il nome del file se viene importato come libreria, e assume il valore \texttt{\_\_main\_\_}
	\item Ci sono le \textbf{format string} che sono un po' come le template string di Javascript e PHP. Dalla 3.5 in poi non serve nemmeno il .format.
	\item Solo i tipi primitivi sono passati per valore, i tipi "complessi" sono passati per valore, quindi il contenuto è passato per riferimento.
	\item Qualsiasi riga di codice non protetta da if o dentro funzioni verrà eseguita. Non esiste un main.
\end{itemize}

\subsection{Altre Caratteristiche}
\begin{itemize}
	\item La keyword import mi permette di importare da altri moduli. Se voglio accedere a una funzione o campo dati specifico, faccio modulo.funzione. Posso accedere alla doc di un oggetto con \texttt{oggetto.\_\_doc\_\_}.
\end{itemize}

\subsection{Eccezioni}
Per lanciare un'eccezione si usa la keyworw \texttt{raise}. Si usano dei blocchi \texttt{try} - \texttt{except}.
%Metto qua lo snippet.
%\definition{Legge di Brooks}{Aggiungere personale ad un progetto in ritardo lo farà solo ritardare.}
\lessonDate{7 Ottobre 2019}

\subsection{Tipi di dato in Python}
I tipi di Python funzionano come in javascript, dove il tipo è associato all'oggetto.
Ci sono vari tipi numerici. Anche i primitivi sono oggetti, in quanto istanze di classi. 

\subsubsection{Numeri}
Si usa, ad esempio la classe \texttt{int}. I primi numeri di Python, circa i primi 256, sono implementati tramite \textbf{singleton}.\\
Alcuni comandi:
\begin{itemize}
	\item \texttt{type()} mi torna il tipo di una variabile
	\item \texttt{isinstance()} controlla il tipo di una variabile.
\end{itemize}
Posso rappresentare qualsiasi intero fino a infinito. I float sono precisi fino a 15 cifre decimali. Ci sono vari operatori, \pyRef{57}.

\subsubsection{Liste}
Sono trattate come degli array. Come javascript, posso avere più tipi di dato all'interno della stessa lista. Posso anche indicizzare al contrario. Esempio: \texttt{[-2]} accede al penultimo elemento della lista.\\
L'operatore di \textbf{slicing} è il seguente \texttt{[x:y]} dove \texttt{x} è mantenuto e \texttt{y} escluso. Posso sempre usare gli indici negativi. Se ometto uno dei due indici parto dall'inizio/fine. Creo sempre un nuovo oggetto.\\
Operatori: \pyRef{64}
\begin{itemize}
	\item \texttt{+}: Somma fra liste, creo un nuovo oggetto.
	\item \texttt{append}: appende un elemento alla fine della lista
	\item \texttt{extend:} aggiunge una lista ad un'altra lista
	\item \texttt{insert:} inserisce un elemento in una certa posizione nella lista
	\item \texttt{in}: del tipo \texttt{if x in list}, torna true e false
	\item \texttt{count} conta le istanze, in caso non ci sono, lancio eccezione
	\item \texttt{del}: \texttt{del list[2]} rimuovo per posizione
	\item \texttt{value}: \texttt{list.remove(3.13)} rimuove per valore
\end{itemize}

\subsubsection{Tuple}
Sono delle liste immutabili. Si scrivono con le tonde, non con le graffe.\\
Siccome non possono cambiare:
\begin{itemize}
 \item Sono più efficienti
 \item Posso usarle come chiave in un dizionario
\end{itemize}
Posso usare più o meno le stesse operazioni sulle liste, apparte quelle che apportano modifiche. Posso usare per assegnazioni multiple a variabili.

\subsubsection{Sets (insiemi)}
Struttura dati non ordinata con elementi univoci. Le creo come una lista ma con le graffe. Si crea un set vuoto con \texttt{set()}. Posso anche crearli da una lista.
Operatori:
\begin{itemize}
	\item \texttt{set.add} se possibile aggiunge un elemento al set
	\item \texttt{set1.update(set2)} unisce due set nel primo set
	\item \texttt{move discard}
	\item \texttt{union, difference ecc.} Tutte le operazioni matematiche sugli insiemi sono implementati. Potrebbe essere necessario ridefinire l'uguaglianza.
\end{itemize}

\subsubsection{Dizionari}
Insieme di coppie chiave-valore. La sintassi è praticamente quella del JSON. Sono praticamente delle HashMap. Il dizionario vuoto si scrive con \texttt{{}}. Sono disponibili i classici metodi che mi aspetterei.

\subsubsection{Stringe}
Si comportano come le liste. Uso len per la lunghezza. Posso delimitare le stringe con \texttt{"}, \texttt{'} e \texttt{```}.\\
Stringhe di formattazione (\pyRef{114}), meglio che guardo la doc. \E simile a js e php, ma tipo printf del C. Esiste anche il comando Template. Ci sono un'infinità di operazioni.


\subsection{Ricorsione}
La ricorsione in Python non è ricorsiva in coda. Quindi insomma lol, potrebbe dare qualche problema. L'iterazione è più efficiente. In Python ho massimo 1000 ricorsioni. Posso aggirare il problema, ma la ricorsione in Python \textbf{fa cagare}.

\lessonDate{14 Ottobre 2019}
\subsection{Comprehension}
Tramite una \textbf{comprehension} diamo una descrizione comprensiva di una lista di dati. \E come dare una formula matematica che descrive un insieme e una proprietà. \E una sorta di map, se vogliamo:
\begin{lstlisting}
>>> {elem:elem**2 for elem in range(1,10)}
{1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
\end{lstlisting}
Posso usarlo per creare liste, dizionari, tuple ecc. \E da preferire rispetto ad usare un map, perchè è molto efficiente.\\
Posso utilizzare la comprehension anche per fare cose tipo un filter:
\begin{lstlisting}[caption=Espressione che crea tutti i quadrati perfetti da uno a cento]
>>> [elem for elem in range(1,100) if (int(elem**.5))**2 == elem]
[1, 4, 9, 16, 25, 36, 49, 64, 81]
\end{lstlisting}
Posso usarlo anche per mergiare set diversi, e fare varie figate. Ad esempio posso fare un prodotto cartesiano (doppio for) in modo figo.
\begin{lstlisting}
>>> {(x,y) for x in range(3) for y in range(5)}
{(0,1),(1,2),(0,0),(2,2),(1,1),(1,4),(0,2),(2,0),(1,3),
(2,3),(2,1),(0,4),(2,4),(0,3),(1,0)}
\end{lstlisting}
Lo svantaggio/problematica di questo metodo è che non mi da modi (facili) per interrompere l'esecuzione di questo finto for.

\lessonDate{21 Ottobre 2019}
\section{Programmazione funzionale}
\E un modo di programmare che scoraggia l'uso dello stato, e dei side effect. L'oggetto primario è la funzione, e il flusso è regolato tramite la \textbf{ricorsione}.
\subsection{Motivi}
Dovrebbe essere più simile al tipo di definizione matematiche a cui dovremmo essere abituati. Il vero motivo è che programmando funzionalmente dovrei commettere \textbf{meno errori}. Questo perchè avere uno stato, e in particolar modo l'assegnazione di variabili, è una delle principali fonti di errori. Oltre a ciò, in un linguaggio di programmazione funzionale è più facile individuare gli errori commessi.

\subsection{Istruzioni a supporto}
Le istruzioni cardine della programmazione funzionale sono il \texttt{map()}, il \texttt{filter()} e il \texttt{reduce()}. Il map e il filter non ritorano direttamente una lista, ma un iterabile. Se dopo voglio una lista, devo mettere questo iterabile dentro il costruttore della lista. Il reduce ha peculiarità che il primo elemento della lista di partenza viene usato come accumulatore. Volendo c'è anche un parametro opzionale per l'accumulatore.

\subsection{Condizionali}
Nella programmazione funzionale pura non è possibile usare il construtto \texttt{if}. Uso quindi lo \textbf{short-circuiting}.
\begin{figure}[H]
\begin{lstlisting}
return (x==1 and 'one') or (x==2 and 'two') or 'other'
\end{lstlisting}
\caption{Esempio di short circuiting}
\end{figure}
Lo short circuiting funziona praticamente come in javascript.

Vado bene a usarlo con le lambda.
\begin{figure}[H]
\begin{lstlisting}
cond = \
 lambda x: \
  (x==1 and block("one")) or (x==2 and block("two")) or (block("other"))
\end{lstlisting}
\caption{Esempio di lambda}
\end{figure}

\subsection{Codice sequenziale}
Nella programmazione funzionale, scrivere il codice in modo sequenziale (aka imperativo) non è accettabile.\\
Posso fare una cosa del genere:
\begin{figure}[H]
\begin{lstlisting}
# let's create an execution utility function
do_it = lambda f: f()

# let f1, f2, f3 (etc) be functions that perform actions
map(do_it, [f1,f2,f3])
# map()-based action sequence
\end{lstlisting}
\end{figure}

\subsection{Funzioni monadiche}
Sono funzioni che causano un side effect ma che comunque ritornano comunque qualcosa.
\begin{lstlisting}
# Funzione Imperativa
def echo_IMP():
	while True:
		x = input("FP -- ")
		if x == 'quit': break
		else: print(x)
		
if __name__ == "__main__": echo_IMP()

#Funzione Monadica Funzionale
echo_FP = \
lambda: monadic_print(input("FP -- "))=='quit' or echo_FP()
if __name__ == "__main__": echo_FP()
\end{lstlisting}

\lessonDate{22 Ottobre 2019}
\section{Clousures}
\E solo sostanzialmente un modo come un altro per dire che posso passare le funzioni come parametro e fare alcune figate.

\section{Generatori}
Un generatore è una funzione che può tornare più volte un valore, tramite il costrutto \texttt{Yield}, e si avanza la funzione tramite la keyword \texttt{next}. Posso usare i generatori anche nei for, e in tal caso non serve che chiamo il next.
\begin{figure}[H]
\begin{lstlisting}[language=python]
def make_counter(x):
	print('entering make_counter')
	while True:
		yield x
		print('incrementing x')
		x = x + 1
...
print(next(make_counter))
\end{lstlisting}
\caption{Esempio di generatore che funge da contatore}
\end{figure}

\section{Tipizzazione Dinamica}
Python funziona un po'come Javascript:
Quando creo una variabile, essa non ha tipo, ma è un semplice riferimento ad un oggetto. \E l'oggetto che contiene il tipo di una variabile. Posso quindi pensare alla variabili come a dei semplici puntatori a oggetti. Come Java e Javascript, python è \textbf{garbage collected}.\\
Per controllare l'uguaglianza fra due variabili esistono due operatori:
\begin{itemize}
\item \texttt{==} controlla l'uguaglianza di valore di due oggetti. Ex \texttt{A == B}
\item \texttt{is} controlla l'uguaglianza di reference fra due oggetti. Ex \texttt{A is B}. Attenzione che siccome interi e altri piccoli oggetti vengono cachati, \texttt{is} in questi casi restituisce sempre \texttt{True}
\end{itemize}

In python il passaggio di parametri a funzione avviene sempre \textbf{per riferimento}. Fanno eccezione alcuni tipi immutabili, come interni, stringhe, e tuple, che vengono passate per valore.

\lessonDate{4 Novembre}
\section{Object Orientation}
I linguaggi di programmazione orientati agli oggetti devono avere tre caratteristiche:
\begin{itemize}
\item Deve avere oggetti
\item Deve avere classi
\item Deve avere l'ereditarietà
\end{itemize}
In python le classi lasciano un po a desiderare. Posso aggiungere arbitrariamente metodi e campi dati alle istanze delle classi, come in javascript. Python è \textbf{object based}.\\
Il problema di questo approccio è il non avere l'accesso all'oggetto \textbf{self} (this), che mi viene dato dall'ereditarietà.
Indico i campi privati con \texttt{\_\_campoPrivato\_\_}. Definisco i metodi astratti di interfaccia con \texttt{def metodo(): pass}. Come javascript, utilizza il \textbf{duck typing}.


\lessonDate{5 Novembre 2019}
Ogni classe e ogni istanza in python ha un attributo \texttt{self.\_\_dict\_\_}, che contiene la lista di attributi di ogni oggetto e ogni classe. Attraverso questa caratteristica, posso fare introspezione e intercessione.\\
In python, quando definisco i metodi di una classe, il primo parametro è sempre \texttt{self}, ovvero un riferimento esplicito al this.\\
All'interno della classe, i metodi sono delle funzioni. Diventano metodi quando provo ad eseguirli, dovendo eseguire il binding della funzione all'istanza. Un metodo collegato è una funzione che passa l'istanza come primo parametro.

\begin{figure}[H]
\begin{lstlisting}
>>> class D:
...   def f(self):
...     return "lol"
... 
>>> d = D()
>>> d.f
<bound method D.f of <__main__.D object at 0x7f68ac0d9990>>
>>> D.f
<function D.f at 0x7f68ac0a28c0>
\end{lstlisting}
\end{figure}

\subsection{Ereditarietà multipla}
Python decide dinamicamente quale dei metodi delle classi base da chiamare. Sostanzialmente python chiama tutti i metodi della gerarchia in modo che può essere sensato, senza chiamare più volte un metodo base. \texttt{Ex. Slide OOP \#7}.

\subsection{Metodi speciali}
Sono metodi come \texttt{\_\_len()\_\_}, \texttt{\_\_str()\_\_}, \texttt{\_\_lt()\_\_}, \texttt{\_\_add()\_\_}, ecc. Essendo metodi fortunelli, non posso riassegnarli a run time. Posso girarci attorno mettendo un altro metodo come valore di ritorno, e assegnando un nuovo funzionamento a questo metodo.\\
Posso usare l'attributo \texttt{\_\_slots\_\_} per definire il tipo di attributi che gli oggetti devono all'interno di una lista sottoclassata possono avere.

\end{document}